## DSA Learning Phase 2: Arrays, Two Pointers & Sorting

## üéØ Core Concepts & Foundations

- [ ] O(1) - Constant Time
- [ ] O(\log n) - Logarithmic Time
- [ ] O(n) - Linear Time
- [ ] O(n \log n) - Linearithmic Time
- [ ] O(n^2) - Quadratic Time
- [ ] O(2^n) - Exponential Time
- [ ] O(n!) - Factorial Time
- [ ] Analyzing space complexity (auxiliary space vs. total space)

## üìö Arrays: Advanced Concepts

- [ ] Prefix Sum - Calculating prefix sums
- [ ] Prefix Sum - Calculating suffix sums
- [ ] Prefix Sum - Applying to range sum queries
- [ ] Sliding Window - Fixed-size sliding window problems (e.g., max sum subarray of size K)
- [ ] Sliding Window - Dynamic-size sliding window problems (e.g., longest substring without repeating characters)
- [ ] Multi-dimensional Arrays - Traversing 2D arrays (row-major, column-major)
- [ ] Multi-dimensional Arrays - Matrix rotation (90 degrees clockwise/counter-clockwise)
- [ ] Multi-dimensional Arrays - Spiral matrix traversal
- [ ] Multi-dimensional Arrays - Searching in a sorted 2D matrix
- [ ] In-Place Operations - Understanding how to modify arrays without significant extra space
- [ ] Handling Edge Cases - Empty arrays, single-element arrays, duplicate values, extreme values

## üìö Stacks: Foundation & Implementation

- [ ] Understanding Stack data structure and LIFO principle
- [ ] Stack Operations (Push, Pop, Peek, Size, isEmpty)
- [ ] Implement stack using array
- [ ] Implement stack using object
- [ ] Reverse a string using stack
- [ ] Evaluate postfix expression
- [ ] Check for balanced parentheses using stack
- [ ] Convert infix expression to prefix
- [ ] Implement queue using two stacks
- [ ] Sort a stack using another stack

## üìö Stacks: Validity Checks & Matching

- [ ] Valid Parentheses (Leetcode 20)
- [ ] Remove all adjacent duplicates (Leetcode 1047)
- [ ] Min Add to Make Parentheses Valid (Leetcode 921)
- [ ] Backspace String Compare (Leetcode 844)
- [ ] Check if HTML tags are properly closed
- [ ] Remove Outermost Parentheses (Leetcode 1021)
- [ ] Score of Parentheses (Leetcode 856)
- [ ] Valid Parenthesis String (Leetcode 678)
- [ ] Minimum Remove to Make Valid Parentheses (Leetcode 1249)
- [ ] Check if a Parentheses String Can Be Valid (Leetcode 2116)

## ÔøΩ Stacks: Enhanced Stack Designs

- [ ] Min Stack (Leetcode 155)
- [ ] Max Stack design
- [ ] Implement Two Stacks in an array
- [ ] Design Stack that supports getMin in O(1)
- [ ] Next Greater Element I (Leetcode 496)

## üìö Stacks: Expression Evaluation

- [ ] Evaluate Reverse Polish Notation (Leetcode 150)
- [ ] Infix to Postfix Conversion
- [ ] Basic Calculator I (Leetcode 224)
- [ ] Decode String (Leetcode 394)
- [ ] Basic Calculator II (Leetcode 227)
- [ ] Basic Calculator III (Leetcode 772)
- [ ] Remove Duplicate Letters (Leetcode 316)
- [ ] Smallest Subsequence of Distinct Characters (Leetcode 1081)
- [ ] Parsing A Boolean Expression (Leetcode 1106)
- [ ] Build an Array With Stack Operations (Leetcode 1441)

## üìö Stacks: Monotonic Stack Problems

- [ ] Daily Temperatures (Leetcode 739)
- [ ] Largest Rectangle in Histogram (Leetcode 84)
- [ ] Next Greater Element II (Leetcode 503)
- [ ] Trapping Rain Water (Leetcode 42)
- [ ] Previous Greater Element
- [ ] Previous Smaller Element
- [ ] Next Smaller Element
- [ ] Maximal Rectangle (Leetcode 85)
- [ ] Sum of Subarray Minimums (Leetcode 907)
- [ ] Online Stock Span (Leetcode 901)
- [ ] Remove K Digits (Leetcode 402)
- [ ] Create Maximum Number (Leetcode 321)
- [ ] 132 Pattern (Leetcode 456)
- [ ] Sum of Subarray Ranges (Leetcode 2104)

## üìö Stacks: Real-World Applications

- [ ] Implement Browser history using stack
- [ ] Implement Undo/Redo functionality
- [ ] Backtracking maze solver using stack
- [ ] Evaluate if string can be generated using push/pop operations
- [ ] Simplify Path (Leetcode 71)
- [ ] Decode String (Leetcode 394)
- [ ] Asteroid Collision (Leetcode 735)
- [ ] Exclusive Time of Functions (Leetcode 636)
- [ ] Baseball Game (Leetcode 682)
- [ ] Validate Stack Sequences (Leetcode 946)
- [ ] Find the Most Competitive Subsequence (Leetcode 1673)
- [ ] Car Fleet (Leetcode 853)
- [ ] Dinner Plate Stacks (Leetcode 1172)

## ‚úåÔ∏è Two-Pointer Technique: Ends Moving Inwards

- [ ] Finding a pair with a given sum in a sorted array
- [ ] Checking for palindromes (strings/arrays)
- [ ] "Container With Most Water" type problems
- [ ] Reversing an array/string in-place

## ‚úåÔ∏è Two-Pointer Technique: Same Direction (Fast & Slow)

- [ ] Removing duplicates from a sorted array (in-place)
- [ ] Moving zeros to the end of an array
- [ ] Finding the middle of a linked list (if you get to linked lists)
- [ ] Detecting cycles in a linked list (if you get to linked lists)

## ‚úåÔ∏è Two-Pointer Technique: Two Different Arrays

- [ ] Merging two sorted arrays
- [ ] Finding intersection of two sorted arrays
- [ ] Finding union of two sorted arrays

## üî¢ Sorting Algorithms: Comparison-Based

- [ ] Bubble Sort - Understand concept
- [ ] Bubble Sort - Implement in JavaScript
- [ ] Bubble Sort - Analyze O(n^2) complexity
- [ ] Selection Sort - Understand concept
- [ ] Selection Sort - Implement in JavaScript
- [ ] Selection Sort - Analyze O(n^2) complexity
- [ ] Insertion Sort - Understand concept
- [ ] Insertion Sort - Implement in JavaScript
- [ ] Insertion Sort - Analyze O(n) best-case, O(n^2) worst/average-case
- [ ] Insertion Sort - Recognize its use for small or nearly sorted data
- [ ] Merge Sort - Understand "Divide and Conquer" principle
- [ ] Merge Sort - Implement merge function
- [ ] Merge Sort - Implement mergeSort (recursive)
- [ ] Merge Sort - Analyze O(n \log n) time complexity (all cases)
- [ ] Merge Sort - Analyze O(n) space complexity
- [ ] Merge Sort - Understand stability
- [ ] Quick Sort - Understand "Divide and Conquer" principle
- [ ] Quick Sort - Implement partition function (e.g., Lomuto or Hoare)
- [ ] Quick Sort - Implement quickSort (recursive)
- [ ] Quick Sort - Analyze O(n \log n) average-case, O(n^2) worst-case
- [ ] Quick Sort - Understand pivot selection strategies and their impact
- [ ] Quick Sort - Analyze O(\log n) space complexity (recursion stack)
- [ ] Heap Sort - Understand Heap data structure (Max-Heap / Min-Heap)
- [ ] Heap Sort - Implement heapify operation
- [ ] Heap Sort - Implement buildMaxHeap / buildMinHeap
- [ ] Heap Sort - Implement heapSort
- [ ] Heap Sort - Analyze O(n \log n) time complexity (all cases)
- [ ] Heap Sort - Analyze O(1) space complexity (in-place)
