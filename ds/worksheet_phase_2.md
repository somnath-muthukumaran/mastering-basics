## DSA Learning Phase 2: Arrays, Two Pointers & Sorting

This is Phase 2 of learning Data Structures and Algorithms. Phase 1 covered array class-based methods. This phase focuses on Array concepts, the Two-Pointer technique, and various Sorting Algorithms. Mark the checkboxes [x] as you implement, understand, and practice problems related to each topic.

## üéØ Core Concepts & Foundations

- [ ] O(1) - Constant Time
- [ ] O(\log n) - Logarithmic Time
- [ ] O(n) - Linear Time
- [ ] O(n \log n) - Linearithmic Time
- [ ] O(n^2) - Quadratic Time
- [ ] O(2^n) - Exponential Time
- [ ] O(n!) - Factorial Time
- [ ] Analyzing space complexity (auxiliary space vs. total space)

## üìö Arrays: Basic Operations

- [ ] Accessing elements by index
- [ ] Traversing an array (for loops, forEach, map, reduce in JS)
- [ ] Insertion at beginning/middle/end (and their complexities)
- [ ] Deletion at beginning/middle/end (and their complexities)
- [ ] Searching (Linear Search)
- [ ] Reversing an array (in-place vs. new array)

## üìö Arrays: Advanced Concepts

- [ ] Binary Search - Iterative implementation
- [ ] Binary Search - Recursive implementation
- [ ] Binary Search - Variations (finding first/last occurrence, ceiling/floor)
- [ ] Searching in a rotated sorted array
- [ ] Prefix Sum - Calculating prefix sums
- [ ] Prefix Sum - Calculating suffix sums
- [ ] Prefix Sum - Applying to range sum queries
- [ ] Sliding Window - Fixed-size sliding window problems (e.g., max sum subarray of size K)
- [ ] Sliding Window - Dynamic-size sliding window problems (e.g., longest substring without repeating characters)
- [ ] Multi-dimensional Arrays - Traversing 2D arrays (row-major, column-major)
- [ ] Multi-dimensional Arrays - Matrix rotation (90 degrees clockwise/counter-clockwise)
- [ ] Multi-dimensional Arrays - Spiral matrix traversal
- [ ] Multi-dimensional Arrays - Searching in a sorted 2D matrix
- [ ] In-Place Operations - Understanding how to modify arrays without significant extra space
- [ ] Handling Edge Cases - Empty arrays, single-element arrays, duplicate values, extreme values

## ‚úåÔ∏è Two-Pointer Technique: Ends Moving Inwards

- [ ] Finding a pair with a given sum in a sorted array
- [ ] Checking for palindromes (strings/arrays)
- [ ] "Container With Most Water" type problems
- [ ] Reversing an array/string in-place

## ‚úåÔ∏è Two-Pointer Technique: Same Direction (Fast & Slow)

- [ ] Removing duplicates from a sorted array (in-place)
- [ ] Moving zeros to the end of an array
- [ ] Finding the middle of a linked list (if you get to linked lists)
- [ ] Detecting cycles in a linked list (if you get to linked lists)

## ‚úåÔ∏è Two-Pointer Technique: Two Different Arrays

- [ ] Merging two sorted arrays
- [ ] Finding intersection of two sorted arrays
- [ ] Finding union of two sorted arrays

## üî¢ Sorting Algorithms: Comparison-Based

- [ ] Bubble Sort - Understand concept
- [ ] Bubble Sort - Implement in JavaScript
- [ ] Bubble Sort - Analyze O(n^2) complexity
- [ ] Selection Sort - Understand concept
- [ ] Selection Sort - Implement in JavaScript
- [ ] Selection Sort - Analyze O(n^2) complexity
- [ ] Insertion Sort - Understand concept
- [ ] Insertion Sort - Implement in JavaScript
- [ ] Insertion Sort - Analyze O(n) best-case, O(n^2) worst/average-case
- [ ] Insertion Sort - Recognize its use for small or nearly sorted data
- [ ] Merge Sort - Understand "Divide and Conquer" principle
- [ ] Merge Sort - Implement merge function
- [ ] Merge Sort - Implement mergeSort (recursive)
- [ ] Merge Sort - Analyze O(n \log n) time complexity (all cases)
- [ ] Merge Sort - Analyze O(n) space complexity
- [ ] Merge Sort - Understand stability
- [ ] Quick Sort - Understand "Divide and Conquer" principle
- [ ] Quick Sort - Implement partition function (e.g., Lomuto or Hoare)
- [ ] Quick Sort - Implement quickSort (recursive)
- [ ] Quick Sort - Analyze O(n \log n) average-case, O(n^2) worst-case
- [ ] Quick Sort - Understand pivot selection strategies and their impact
- [ ] Quick Sort - Analyze O(\log n) space complexity (recursion stack)
- [ ] Heap Sort - Understand Heap data structure (Max-Heap / Min-Heap)
- [ ] Heap Sort - Implement heapify operation
- [ ] Heap Sort - Implement buildMaxHeap / buildMinHeap
- [ ] Heap Sort - Implement heapSort
- [ ] Heap Sort - Analyze O(n \log n) time complexity (all cases)
- [ ] Heap Sort - Analyze O(1) space complexity (in-place)

## üßÆ Sorting Algorithms: Non-Comparison Based

- [ ] Counting Sort - Understand concept and constraints (integer range)
- [ ] Counting Sort - Implement in JavaScript
- [ ] Counting Sort - Analyze O(n + k) time complexity
- [ ] Radix Sort - Understand concept (digit-by-digit sorting)
- [ ] Radix Sort - Implement in JavaScript (often uses Counting Sort as a subroutine)
- [ ] Radix Sort - Analyze O(nk) time complexity
- [ ] Bucket Sort - Understand concept and constraints (uniform distribution)
- [ ] Bucket Sort - Implement in JavaScript
- [ ] Bucket Sort - Analyze O(n + k) average-case time complexity

## üíª JavaScript Array Built-in Methods

- [ ] `sort()` ‚Äì Sorts the elements in place.

## üí° General Interview Preparation Tips

- [ ] Practice explaining algorithms verbally
- [ ] Practice writing clean, readable, and well-commented code
- [ ] Test your code with various edge cases
- [ ] Understand when to use built-in sort methods (Array.prototype.sort() in JS) and when to implement your own
- [ ] Consider alternative approaches and discuss their trade-offs
